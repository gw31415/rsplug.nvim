-- Auto generated by rsplug
local event2pkgid = { <% for (val, ids) in event2pkgid {%>['<%=val%>']={<% for id in ids {%>'<%=id%>',<%}%>},<%}%> }

return {
	---@param ctx vim.api.keyset.create_autocmd.callback_args
	autocmd_callback = function(ctx)
		---@param options vim.api.keyset.exec_autocmds
		local function doautocmd(options)
			local opts = options or {}
			vim.api.nvim_exec_autocmds(ctx.event, vim.tbl_deep_extend('force', {
				buffer = ctx.buf,
				modeline = false,
				data = ctx.data,
			}, opts))
		end

		local old_autocmds = vim.api.nvim_get_autocmds { event = ctx.event }
		for _, pkg in pairs(event2pkgid[ctx.event] or {}) do
			require '_rsplug'.packadd(pkg)
		end
		local autocmds = vim.api.nvim_get_autocmds { event = ctx.event }
		local new_autocmds = require '_rsplug'.get_new_autocmds(autocmds, old_autocmds)

		if #new_autocmds == 0 then
			return
		end

		-- Some workarounds
		if ctx.event == 'InsertCharPre' then
			vim.fn.feedkeys(vim.v.char)
			vim.v.char = ''
		end
		if vim.fn.exists '#BufReadCmd' and ctx.event == 'BufNew' then
			pcall(doautocmd)
			return
		end


		local executed_groups = {}
		local execute_functions = {}
		for _, autocmd in ipairs(new_autocmds) do
			if autocmd.group and not executed_groups[autocmd.group] then
				executed_groups[autocmd.group] = true
				table.insert(execute_functions, function()
					doautocmd { group = autocmd.group }
				end)
			else
				-- Fallback
				pcall(doautocmd)
				return
			end
		end

		for _, func in ipairs(execute_functions) do
			pcall(func)
		end
	end,
}
